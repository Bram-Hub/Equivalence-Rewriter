# Equivalence Rewriter
## Authors
2011
Matthew Schoen

## About
This is my prototype Equivalence Rewriter. The purpose of this program was to design a system for inputting logic statements and converting them to other forms using a set of equivalence statements.
--How To Use the Program--
A copy of the program executable itself is in the topmost folder, as well as an additional copy WITHOUT special symbols (which failed to display correctly on several computers). Use this second copy if statements display with boxes for every symbol. The program should (hopefully) run on most windows machines by default, but I have not tried it on any computer without Windows 7 and a copy of Visual Studio installed (which may add the necessary dependencies).
	To begin with the program, simply write a logic statement in lisp-like syntax in the textbox in the upper left of the window and hit parse to lock in a statement (see below for syntax details). From there, you can select equivalence rules from the list on the right to try against your statement (either double-click a rule or hit "Apply Rule" to test it, or hit "Apply All" to make a list of all possible changes). If they fit the pattern of one or both sides of a rule, the possible conversions will be listed under the statement (double-click one to move it to the statement box). Equivalence Rules can also be added, removed or modified using the buttons above the list.]

--How To Input Logic Statements--
The program was designed similarly to Slate, with the input syntax in similar lisp-like form. Every logic statement aside from Atomic values is entered in parentheses, with the statement's arguments following the type of statement, separated by spaces. The following are acceptable inputs for statements:
- Atomic claims: Single letters, A-Z, uppercase only. Also accepts tautologies and contradictions (lowercase).
	- Ex: A, B, C, X, Y, Z, true, false
	- These are used as wildcards (representing any other statement) when defining equivalence rules
- Negations: A single statement following "not"
	- Ex: (not A), (not B)
- Binary operators: Two statements following "and", "or", "if", "iff", "xor" or "="
	- Ex: (and A B), (if X Y), (iff (and A B) (or X Y))
- Functions: any number of lowercase variables of any length following the uppercase name of a function
	- Ex: (F x1 y1), (LeftOf a b), (Eats bacon)
After input is finished and the Parse button is pressed, a correctly formatted statement will be displayed in regular notation.

--Code Work (Decently Confusing)--
The code for this project was done in Visual C# and is split among several files (a couple auto-generated by Visual Studio for the GUI). Most of the important code has notes in the comments about what it's for and how it works. Some basic GUI work was done in the following files:
- StatementBox.cs: A custom control pairing textboxes to Parse buttons for statement input
- RuleDialog.cs: A custom dialog for inputting new equivalence rules
- frmER.cs: The main window frame and handlers for each control
The most work, however, was done in the following 2 classes:
- Statement.cs: The abstract Statement class held the framework for each logic statement input by the user. With its subclasses (in the same file) it is used to parse the input into complete statements by splitting it up and using regular expressions to splice it into different parts. The NewParse method is first called on Statement, which then splits the lisp string into pieces and calls the TryParse methods of each subclass on them to create a complete Statement object. Each Statement object stores its own name (either a type, like "if" or "not", or its value, like "A" or "true") and a variable number of arguments, each of which is another Statement. Originally I had planned to compare the branching structures of objects together to check for equivalences, but when this proved too complex I switched to more regular expression manipulation in the next file.
- Equivalence.cs: This class holds Equivalence rules in the form of 2 equivalent Statement objects and a name. The work done by this class ended up being far more complex than initially estimated, as you can see by the extra variables stored. In addition to the Statements, the class generates and stores a regular expression for each statement. It does so by essentially re-generating the lisp-like syntax of each Statement with capture groups in place of each atomic claim (A-Z), and back-references in place of atomic claims that have already been captured. The class also stores a formatting template copy of each Statement's lisp with numbered tokens in place of each atomic claim. Finally, each Statement has a corresponding map object, which keeps track of which atomic claims were seen in which order (mapping claims to indices).

	Then the process of generating an equivalent claim goes like this:
1) The input is matched to the first Statement's regex to see if it's a match
2) Each atomic claim in the first Statement is checked against the other Statement's map to see where they should go in the new Statement
3) The parts of the input captured by the Regex are ordered in an array based on where the corresponding parts of Statement 1 go in Statement 2
4) If the array has any empty spots, it means that certain parts of Statement 2 don't have corresponding values in Statement 1, so they are assigned atomic claims that are not already in use by the input Statement
5) The array and formatting template for Statement 2 are passed into a string formatter to be turned into the lisp for a finalized Statement
6) The entire process is repeated to check the input against Statement 2

...It's very confusing, but works well so far.

--Potential Future Improvements--
While the program serves its intended purpose well, it is far from perfect, and I was unable to complete all of the additions I initially had planned. Some improvements for the future:
- Add support for Predicate logic
- Better support for constants
- Loading/saving equivalence rules from/to a file
- Support for generalized conjunction/disjunction (conjuncting/disjuncting more than 2 items at once)
- The ability to recognize an equivalent pattern within a Statement's sub-statements (which became difficult with the switch to regular expressions and the lisp-generating means by which new statements are formed)
- A more reliable way to display logic symbols across all computers
